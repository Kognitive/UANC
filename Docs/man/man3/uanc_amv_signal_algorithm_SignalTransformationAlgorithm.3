.TH "uanc::amv::signal::algorithm::SignalTransformationAlgorithm< datamodel, viewmodel >" 3 "Tue Mar 28 2017" "Version 0.1" "UANC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
uanc::amv::signal::algorithm::SignalTransformationAlgorithm< datamodel, viewmodel > \- Every algorithm used inside has to be derived by this class\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <SignalTransformationAlgorithm\&.h>\fP
.PP
Inherits \fBuanc::amv::Algorithm< viewmodel >\fP\&.
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "std::shared_ptr< datamodel > \fBexecute\fP (std::shared_ptr< \fBuanc::amv::InvertedModel\fP > input) final"
.br
.RI "\fIExecuted an algorithm with the given input model\&. \fP"
.ti -1c
.RI "std::shared_ptr< datamodel > \fBgetModel\fP ()"
.br
.RI "\fIGets a pointer, to access the model of the algorithm\&. \fP"
.ti -1c
.RI "virtual void \fBtransform\fP (std::shared_ptr< \fBuanc::amv::InvertedModel\fP > input)=0"
.br
.RI "\fIInverts the input signal\&. \fP"
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 

.SS "template<typename datamodel, typename viewmodel = datamodel>
.br
class uanc::amv::signal::algorithm::SignalTransformationAlgorithm< datamodel, viewmodel >"
Every algorithm used inside has to be derived by this class\&. 

This represents an ANCAlgorithm\&. So every inverting algorithm has to be derived by this\&. In addition one can specify the data model and the view model\&. If you want to use only a subset of the data you can specify a view model which is actually a parent of the data model\&. If there is no view model supplied, they will be handled, as if they are the same
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIdatamodel\fP The data model to use, has to be inherited from viewmodel 
.br
\fIviewmodel\fP The view model to use, has to be inherited from \fBSignalModel\fP 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<typename datamodel, typename viewmodel = datamodel> std::shared_ptr<datamodel> \fBuanc::amv::signal::algorithm::SignalTransformationAlgorithm\fP< datamodel, viewmodel >::execute (std::shared_ptr< \fBuanc::amv::InvertedModel\fP > input)\fC [inline]\fP, \fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Executed an algorithm with the given input model\&. This method first all gets an empty model from the deriving class\&. Afterwards it inverts the signal and passed back the model, which was created during the execution stage\&.
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP The input model of the signal\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The created model from the data of the inversion\&. 
.RE
.PP

.PP
Implements \fBuanc::amv::Algorithm< viewmodel >\fP\&.
.SS "template<typename datamodel, typename viewmodel = datamodel> std::shared_ptr<datamodel> \fBuanc::amv::signal::algorithm::SignalTransformationAlgorithm\fP< datamodel, viewmodel >::getModel ()\fC [inline]\fP, \fC [protected]\fP"

.PP
Gets a pointer, to access the model of the algorithm\&. Getter for the model used inside of the algorithm\&. This pointer can be modified by deriving classes to manipulate the model\&.
.PP
\fBReturns:\fP
.RS 4
The pointer to the data model stored inside\&. 
.RE
.PP

.SS "template<typename datamodel, typename viewmodel = datamodel> virtual void \fBuanc::amv::signal::algorithm::SignalTransformationAlgorithm\fP< datamodel, viewmodel >::transform (std::shared_ptr< \fBuanc::amv::InvertedModel\fP > input)\fC [protected]\fP, \fC [pure virtual]\fP"

.PP
Inverts the input signal\&. This is actually capable of transforming the input model into another data representation, which is then used to display it inside of the gui\&.
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP The input model containing the original signal\&. 
.RE
.PP

.PP
Implemented in \fBuanc::amv::signal::algorithm::FFTTransformationAlgorithm\fP, \fBuanc::amv::signal::algorithm::IdentityTransformationAlgorithm\fP, and \fBuanc::amv::signal::algorithm::SpectrogramTransformationAlgorithm\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for UANC from the source code\&.
