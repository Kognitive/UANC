.TH "uanc::amv::Algorithm< outmodel >" 3 "Fri Mar 24 2017" "Version 0.1" "UANC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
uanc::amv::Algorithm< outmodel > \- This is an algorithm used for defining more specific algorithms\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Algorithm\&.h>\fP
.PP
Inherits \fBuanc::amv::IAlgorithm\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBfillView\fP () final"
.br
.RI "\fIFills the view with the data\&. \fP"
.ti -1c
.RI "\fBIAlgorithmView\fP * \fBgetView\fP () final"
.br
.RI "\fIGets a reference to the associated view\&. \fP"
.ti -1c
.RI "void \fBprocess\fP (std::shared_ptr< \fBuanc::amv::InvertedModel\fP > input) final"
.br
.RI "\fIProcesses the input signal model\&. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual std::shared_ptr< outmodel > \fBexecute\fP (std::shared_ptr< \fBuanc::amv::InvertedModel\fP > input)=0"
.br
.RI "\fIExecuted an algorithm with the given input model\&. \fP"
.ti -1c
.RI "virtual \fBAlgorithmView\fP< outmodel > * \fBconstructView\fP ()=0"
.br
.RI "\fIConstructs a view, which can handle the outmode of the algorithm\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class outmodel>
.br
class uanc::amv::Algorithm< outmodel >"
This is an algorithm used for defining more specific algorithms\&. 

This class has to be inherited by any algorithm to be used inside the application\&. It knows which model the algorithm outputs to define a consistent interface\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIoutmodel\fP This is the model generated by the algorithm\&. Has to be derived from \fBSignalModel\fP\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<class outmodel> virtual \fBAlgorithmView\fP<outmodel>* \fBuanc::amv::Algorithm\fP< outmodel >::constructView ()\fC [protected]\fP, \fC [pure virtual]\fP"

.PP
Constructs a view, which can handle the outmode of the algorithm\&. The view should be created inside of this function\&. Remember, that the view has to be able, to deal with the template parameterized data model of the algorithm\&.
.PP
\fBReturns:\fP
.RS 4
The created view\&. 
.RE
.PP

.PP
Implemented in \fBuanc::amv::anc::algorithm::InverseFFTAlgorithm\fP, \fBuanc::amv::signal::algorithm::FFTTransformationAlgorithm\fP, \fBuanc::amv::anc::algorithm::QuinticSplines\fP, \fBuanc::amv::anc::algorithm::InverseDirectAlgorithm\fP, \fBuanc::amv::anc::algorithm::LinearExtrapolation\fP, \fBuanc::amv::signal::algorithm::SpectrogramTransformationAlgorithm\fP, and \fBuanc::amv::signal::algorithm::IdentityTransformationAlgorithm\fP\&.
.SS "template<class outmodel> virtual std::shared_ptr<outmodel> \fBuanc::amv::Algorithm\fP< outmodel >::execute (std::shared_ptr< \fBuanc::amv::InvertedModel\fP > input)\fC [protected]\fP, \fC [pure virtual]\fP"

.PP
Executed an algorithm with the given input model\&. This method must be implemented by deriving algorithms, and should execute the algorithm on the input data, generating the correct output model\&.
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP The input model of the signal\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The created model from the data of the algorithm execution\&. 
.RE
.PP

.PP
Implemented in \fBuanc::amv::signal::algorithm::SignalTransformationAlgorithm< datamodel, viewmodel >\fP, \fBuanc::amv::signal::algorithm::SignalTransformationAlgorithm< InvertedModel >\fP, \fBuanc::amv::signal::algorithm::SignalTransformationAlgorithm< model::FFTModel >\fP, and \fBuanc::amv::signal::algorithm::SignalTransformationAlgorithm< model::SpectrogramModel >\fP\&.
.SS "template<class outmodel> void \fBuanc::amv::Algorithm\fP< outmodel >::fillView ()\fC [inline]\fP, \fC [final]\fP, \fC [virtual]\fP"

.PP
Fills the view with the data\&. This method fills the view with some data\&. It basically checks, if the algorithm was already executed and if a view was integrated in the application\&. If so it plugs the data inside of the view\&. 
.PP
Implements \fBuanc::amv::IAlgorithm\fP\&.
.SS "template<class outmodel> \fBIAlgorithmView\fP* \fBuanc::amv::Algorithm\fP< outmodel >::getView ()\fC [inline]\fP, \fC [final]\fP, \fC [virtual]\fP"

.PP
Gets a reference to the associated view\&. This method uses the singleton and the template pattern to create a unique view\&. The corresponding constructView function gets implemented by a leaf class\&.
.PP
\fBReturns:\fP
.RS 4
The associated view\&. 
.RE
.PP

.PP
Implements \fBuanc::amv::IAlgorithm\fP\&.
.SS "template<class outmodel> void \fBuanc::amv::Algorithm\fP< outmodel >::process (std::shared_ptr< \fBuanc::amv::InvertedModel\fP > input)\fC [inline]\fP, \fC [final]\fP, \fC [virtual]\fP"

.PP
Processes the input signal model\&. This method processes the signal model passed into this function\&. It basically ensures that the function gets called only once and that the generated data is saved inside\&. It measures the time needed for the execution process\&.
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP The input model of the signal\&. 
.RE
.PP

.PP
Implements \fBuanc::amv::IAlgorithm\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for UANC from the source code\&.
