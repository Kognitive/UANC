/*
 * This file is subject to the terms and conditions defined in
 * file 'LICENSE.txt', which is part of this source code package.
 */

#ifndef UANC_ALGORITHM_H
#define UANC_ALGORITHM_H

#include "IAlgorithm.h"
#include "AlgorithmView.h"

namespace uanc {
namespace amv {

/** \brief This is an algorithm used for defining more specific algorithms.
 *
 * This class has to be inherited by any algorithm to be used inside the application.
 * It knows which model the algorithm outputs to define a consistent interface.
 *
 * @tparam outmodel This is the model generated by the algorithm. Has to be derived from SignalModel.
 */
template<class outmodel>
class Algorithm : public IAlgorithm {

  // Static check, whether the correct model is used.
  static_assert(std::is_base_of<InvertedModel, outmodel>::value, "You have to use a SignalModel in any Algorithm.");

 public:

  /** \brief Fills the view with the data.
   *
   * This method fills the view with some data. It basically checks, if the algorithm was already
   * executed and if a view was integrated in the application. If so it plugs the data inside
   * of the view.
   */
  void fillView() final {

    // Do some error checks
    if (!this->executed) {
      throw new std::runtime_error("Algorithm was not executed. You have to call process(SignalModel) first.");
    }

    if (this->_builtView == nullptr) {
      throw new std::runtime_error("View was not built. You have to call getView() first.");
    }

    // simply apply the inmodel to the view
    this->_builtView->setData(this->_builtModel);
  }

  /** \brief Gets a reference to the associated view.
   *
   * This method uses the singleton and the template pattern to create a unique view.
   * The corresponding constructView function gets implemented by a leaf class.
   *
   * @return The associated view.
   */
  IAlgorithmView *getView() final {
    if (this->_builtView == nullptr) {
      this->_builtView = this->constructView();
    }
    return this->_builtView;
  }

  /** \brief Processes the input signal model.
   *
   * This method processes the signal model passed into this function.
   * It basically ensures that the function gets called only once and that
   * the generated data is saved inside.
   * It measures the time needed for the execution process.
   *
   * \param[in] input The input model of the signal.
   */
  void process(std::shared_ptr<uanc::amv::InvertedModel> input) final {

    // check if the algorithm was executed before
    if (!executed) {
      this->_builtModel = this->execute(input);
    }

    executed = true;
  }

 protected:

  /** \brief Executed an algorithm with the given input model.
   *
   * This method must be implemented by deriving algorithms, and should execute the
   * algorithm on the input data, generating the correct output model.
   *
   * \param[in] input The input model of the signal.
   *
   * \return The created model from the data of the algorithm execution.
   */
  virtual std::shared_ptr<outmodel> execute(std::shared_ptr<uanc::amv::InvertedModel> input) = 0;

 private:

  /** \brief True, iff algorithm was executed.
   *
   * This flag gets used inside of the class to determine whether the
   * algorithm was already executed or not.
   */
  bool executed = false;

  /** \brief Holds a built view, if there is one.
   *
   * This field holds the constructed model of the view. It gets used, so that
   * no view is built twice.
   */
  AlgorithmView<outmodel> *_builtView = nullptr;

  /** \brief Holds the built model.
   *
   * This field contains a nullptr, iff !executed.
   */
  std::shared_ptr<outmodel> _builtModel = nullptr;

 protected:

  /** \brief Constructs a view, which can handle the outmode of the algorithm.
   *
   * The view should be created inside of this function. Remember, that the view
   * has to be able, to deal with the template parameterized data model of the
   * algorithm.
   *
   * @return The created view.
   */
  virtual AlgorithmView<outmodel> *constructView() = 0;
};

}
}

#endif //UANC_ALGORITHM_H
